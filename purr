#!/bin/zsh

# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Error code bands:
# 50-59: Irrecoverable environment-based error.
#   51 - Shell does not support purr.
# 60-69: Irrecoverable ADB-related error.
#   61 - Could not get a serial number.

timeout() {
    PERL_BADLANG=0 perl -e 'alarm shift; exec @ARGV' "$@"
}

wait_for_file() {
    while ! [ -s $1 ]; do
        sleep 0.01
    done
}

# We want to avoid the case where we don't have any input coming through,
# causing a block until an error is thrown.
wait_for_input_streams() {
    timeout 0.1 wait_for_file $purr_verbose_input_cache
    timeout 0.1 wait_for_file $purr_info_input_cache
    timeout 0.1 wait_for_file $purr_warning_input_cache
    timeout 0.1 wait_for_file $purr_error_input_cache
}

# Queries the user to choose between all connected adb devices.
# Output: Serial number of the chosen adb device, to be used in adb -s $(pick_serial).
pick_serial() {

    # Checks if we want to return just the $ANDROID_SERIAL serial.
    if [ ! -z $ANDROID_SERIAL ]; then
        __pick_serial_wait $ANDROID_SERIAL
        echo $ANDROID_SERIAL
        return 0
    fi

    # Check if any ADB devices are found.
    local adb_devices=""
    local device_count=""
    while [ -z $adb_devices ]; do
        __pick_serial_wait

        adb_devices=$(adb devices | tail -n +2 | sed '/^\s*$/d' | sort)
        device_count=$(echo $adb_devices | /usr/bin/wc -l)

        # Checks how many devices are in a non-connected state.
        local disconnected_devices=$(/usr/bin/grep ".*offline.*" <<<$adb_devices | sort)
        local disconnected_count=$(/usr/bin/grep -c ".*offline.*" <<<$adb_devices | sort)

        # Checks whether there are any devices left that can be connected to.
        if [ $disconnected_count -eq $device_count ]; then
            echo "All available devices are disconnected. Waiting..." >> /dev/tty
            sleep 2
            __pick_serial_wait

            adb_devices=""
            device_count=""
        elif [ $disconnected_count -ne 0 ]; then
            echo "Skipped offline devices:" >> /dev/tty
            echo $disconnected_devices >> /dev/tty
            adb_devices=$(/usr/bin/grep -v ".*offline.*" <<<$adb_devices | sort)
        fi
    done

    # Check if only one device is found. If it is, we'll just use it.
    if [ $device_count -eq 1 ]; then
        local stripped_device=$(echo "$adb_devices" | xargs)
    else
        if command -v rg &>/dev/null; then
            local stripped_device=$(FZF_DEFAULT_COMMAND="echo \"$adb_devices\"" $fzf_purr $fzfpnh "--height=25%" --preview-window=right,50%,wrap \
                "--preview=adb -s \$(cut -f1 <<< {}) shell getprop | rg '(ro.bootimage.build.date]|ro.product.name|ro.bootimage.build.version.incremental])' | awk -F ']:' '{print \$2}' | sed 's/]//g' | sed 's/\[//g' " | xargs)
        else
            local stripped_device=$(FZF_DEFAULT_COMMAND="echo \"$adb_devices\"" $fzf_purr $fzfpnh "--height=25%" | xargs)
        fi
    fi

    # If the user exits fzf without picking.
    if [ -z $stripped_device ]; then
        echo "No serial number selected."
        return 18
    fi

    # Cuts the serial down to just the number.
    echo "$(cut -d' ' -f1 <<<$stripped_device)" # Grab the serial from selection.
}

__pick_serial_wait() {
    if [ ! -z $1 ]; then
        local serial_stmt="-s $1"
    fi

    # See if any devices are immediately connected before printing a connect message.
    timeout 1 "adb $serial_stmt wait-for-device" 2> /dev/null
    ret=$?
    
    # If we can't find any immediate connections, go into a longer waiting period.
    if [ $ret -eq 124 ] || [ $ret -eq 142 ]; then
        echo "Waiting on a device to connect..." > /dev/tty
        adb $serial_stmt wait-for-device
        echo "Device connected." > /dev/tty
    fi
}

__purr_create_files() {
   local dir_name=$1

    if [ -z $dir_name ]; then
        echo "Can't parse directory name."
        exit 1
    fi

    # File to print input into.
    purr_input_cache="$dir_name/purr-input-cache.purr"
    /usr/bin/touch $purr_input_cache

    # File to print input into.
    purr_instruction_cache="$dir_name/instructions.purr"
    /usr/bin/touch $purr_instruction_cache

    # File to use for editor input.
    purr_editor_input_cache="$dir_name/editor-input-cache.purr"
    /usr/bin/touch $purr_editor_input_cache

    # File to use to keep track of input stream.
    purr_input_stream_cache="$dir_name/input-stream.purr"
    /usr/bin/touch $purr_input_stream_cache

    # File to use to keep track of the stream header message.
    purr_stream_header_cache="$dir_name/stream-header.purr"
    /usr/bin/touch $purr_stream_header_cache

    # File to use to keep track of the query during aborting commands.
    purr_query_cache="$dir_name/query-cache.purr"
    /usr/bin/touch $purr_query_cache

    # File to use to keep track of the sort header message.
    purr_sort_header_cache="$dir_name/sort-header.purr"
    /usr/bin/touch $purr_sort_header_cache

    # File to use to keep track of whether scroll lock is on.
    purr_slock_cache="$dir_name/scroll-lock-header.purr"
    /usr/bin/touch $purr_slock_cache

    # File to use to keep track of the serial number.
    purr_serial_cache="$dir_name/serial-cache.purr"
    /usr/bin/touch $purr_serial_cache

    # File to use to keep track of the state of the device connection.
    purr_connection_state_cache="$dir_name/connection-state.purr"
    /usr/bin/touch $purr_connection_state_cache

    # File to use to keep track of the state of the fzf preview window's visibility.
    purr_preview_visible_cache="$dir_name/preview-visibility-cache.purr"
    /usr/bin/touch $purr_preview_visible_cache

    # File to use to keep track of the state of the fzf preview window's command.
    purr_preview_command_cache="$dir_name/preview-command-cache.purr"
    /usr/bin/touch $purr_preview_command_cache

    # File to communicate with the background handler.
    purr_background_handler_cache="$dir_name/background-handler-IO.purr"
    /usr/bin/touch $purr_background_handler_cache

    # File to communicate what the accept command intent was.
    purr_accept_command_cache="$dir_name/purr_accept_command_cache.purr"
    /usr/bin/touch $purr_accept_command_cache

    # File to keep track of what time we want to start at.
    purr_time_start_cache="$dir_name/purr_time_start_cache.purr"
    /usr/bin/touch $purr_time_start_cache

    purr_unique_cache="$dir_name/purr_unique_cache.purr"
    /usr/bin/touch $purr_unique_cache

    # Files to input cache the streams into.
    purr_error_input_cache="$dir_name/error-input-cache.purr"
    purr_warning_input_cache="$dir_name/warning-input-cache.purr"
    purr_info_input_cache="$dir_name/info-input-cache.purr"
    purr_verbose_input_cache="$dir_name/verbose-input-cache.purr"

    # Files to input cache the unique version of the streams into.
    purr_error_unique_checksum_cache="$dir_name/error-unique-checksum-cache.purr"
    purr_warning_unique_checksum_cache="$dir_name/warning-unique-checksum-cache.purr"
    purr_info_unique_checksum_cache="$dir_name/info-unique-checksum-cache.purr"
    purr_verbose_unique_checksum_cache="$dir_name/verbose-unique-checksum-cache.purr"

    # Files to input cache the unique version of the streams into.
    purr_error_input_cache_unique="$dir_name/error-unique-input-cache.purr"
    purr_warning_input_cache_unique="$dir_name/warning-unique-input-cache.purr"
    purr_info_input_cache_unique="$dir_name/info-unique-input-cache.purr"
    purr_verbose_input_cache_unique="$dir_name/verbose-unique-input-cache.purr"

    # File to use for purr history. This file is not removed between sessions.
    purr_history_cache="/var/tmp/history.purr"
    /usr/bin/touch $purr_history_cache

    # File to use for the purr history counter.
    purr_history_counter_cache="$dir_name/history-counter.purr"
    /usr/bin/touch $purr_history_counter_cache

    # File to use for purr history location.
    purr_history_pointer_cache="$dir_name/history-pointer.purr"
    /usr/bin/touch $purr_history_pointer_cache

    purr_spc_purpose_cache="$dir_name/spc-purpose-cache.purr"
    /usr/bin/touch $purr_spc_purpose_cache

    # We'll use this to cache the result of ADB commands.
    purr_adb_cache="$dir_name/adb-cache.purr"
    /usr/bin/touch $purr_adb_cache
}

# Ensures the user's environment can support running purr.
__purr_check_env() {

    # Ensures that the calling shell in zsh.
    if [ -n "$ZSH_VERSION" ]; then
        : # Left blank for clarity.
    elif [ -n "$BASH_VERSION" ]; then
        echo "Bash detected. Purr will malfunction. Aborting."
        return 51
    else
        echo "Unsure of shell. Purr may malfunction. Aborting."
        return 51
    fi

    # Ensures that the user has adb installed.
    if ! type adb &> /dev/null; then
        echo "You don't have adb installed."
        echo "Running: sudo apt-get install adb"
        /usr/bin/sudo apt-get install adb
        return 52
    fi
}

# Writes the instruction file which will be displayed in the 
# instruction header when purr starts.
__purr_print_instructions() {
    local purr_instruction_cache=$1

    echo "\x1b[1;1m\x1b[1;4mInstructions\x1b[1;0m" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-p:\x1b[1;0m Toggle this preview window on and off" >> $purr_instruction_cache
    echo "  \x1b[1;1mShift-up/down:\x1b[1;0m Scroll up/down in the instruction window" >> $purr_instruction_cache
    echo "  \x1b[1;1mEscape:\x1b[1;0m Exit" >> $purr_instruction_cache
    echo "" >> $purr_instruction_cache
    echo "\x1b[1;1m\x1b[1;4mStream Modes\x1b[1;0m" >> $purr_instruction_cache
    echo "  \x1b[1;1mF1/2/3/4:\x1b[1;0m Show Error/Warning/Info/Verbose streams, respectively" >> $purr_instruction_cache
    echo "  \x1b[1;1mF5:\x1b[1;0m Show the serial selection menu" >> $purr_instruction_cache
    echo "  \x1b[1;1mF6:\x1b[1;0m Enter ADB command mode" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-r:\x1b[1;0m Show the history menu" >> $purr_instruction_cache
    echo "" >> $purr_instruction_cache
    echo "\x1b[1;1m\x1b[1;4mPreview\x1b[1;0m" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-p:\x1b[1;0m Toggles the preview window on/off" >> $purr_instruction_cache
    echo "  \x1b[1;1mF7:\x1b[1;0m Shows the instruction preview" >> $purr_instruction_cache
    echo "  \x1b[1;1mF9:\x1b[1;0m Shows line context in the current stream" >> $purr_instruction_cache
    echo "  \x1b[1;1mF10:\x1b[1;0m Shows line context in the verbose stream" >> $purr_instruction_cache
    echo "  \x1b[1;1mShift-up/down:\x1b[1;0m Scroll up/down in the preview window" >> $purr_instruction_cache
    echo "  \x1b[1;1mHome/End:\x1b[1;0m Scroll one page in the preview window" >> $purr_instruction_cache
    echo "" >> $purr_instruction_cache
    echo "\x1b[1;1m\x1b[1;4mNavigation\x1b[1;0m" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-s:\x1b[1;0m Enable Scroll Lock" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-j:\x1b[1;0m Toggle between Chronological and Relevance sort" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-f:\x1b[1;0m Go to selected line" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-alt-s:\x1b[1;0m Add selected lines tag to the query" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-alt-d:\x1b[1;0m Remove selected lines tag to the query, or adds inverse tag if it doesn't exist" >> $purr_instruction_cache
    echo "" >> $purr_instruction_cache
    echo "\x1b[1;1m\x1b[1;4mADB Controls\x1b[1;0m" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-w:\x1b[1;0m Issues 'adb logcat -c' to permanently wipe device logs" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-t:\x1b[1;0m Trims logs to the selected entries timestamp" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-alt-t:\x1b[1;0m Removes any applied trim" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-h:\x1b[1;0m In ADB command mode, attempts to get the help menu of a command" >> $purr_instruction_cache
    echo "  \x1b[1;1mEnter:\x1b[1;0m  In ADB command mode, execute the current query as:" >> $purr_instruction_cache
    echo "          'adb -s \$serial shell \$query'" >> $purr_instruction_cache
    echo "" >> $purr_instruction_cache
    echo "\x1b[1;1m\x1b[1;4mHistory\x1b[1;0m" >> $purr_instruction_cache
    echo "  \x1b[1;1mAlt-shift-up/down:\x1b[1;0m Scroll up/down through history items" >> $purr_instruction_cache
    echo "  \x1b[1;1mEnter:\x1b[1;0m Select an item from the history menu" >> $purr_instruction_cache
    echo "" >> $purr_instruction_cache
    echo "\x1b[1;1m\x1b[1;4mSerial\x1b[1;0m" >> $purr_instruction_cache
    echo "  \x1b[1;1mEnter:\x1b[1;0m Select an item from the serial menu" >> $purr_instruction_cache
    echo "" >> $purr_instruction_cache
    echo "\x1b[1;1m\x1b[1;4mMisc.\x1b[1;0m" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-v:\x1b[1;0m Open selected line in text editor" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-y:\x1b[1;0m Copy selected lines" >> $purr_instruction_cache
    echo "  \x1b[1;1mTab:\x1b[1;0m Select multiple lines" >> $purr_instruction_cache
    echo "  \x1b[1;1mCtrl-\:\x1b[1;0m Print simple device information to the clipboard and start a background process to save a bug report to /tmp/bug-report-\$device-\$date.zip." >> $purr_instruction_cache
}

__purr_cleanup() {
    local dir_name=$1

    # Send a message to the background threads that they need to die.
    if [ -f $purr_background_handler_cache ]; then
        echo "cleanup" >> $purr_background_handler_cache
    fi

    # Delete all of the cached state files.
    if [ -d $dir_name ]; then
        rm -r $dir_name &> /dev/null
    fi
}

# The background handler is responsible for starting and killing
# the stream threads. It uses the purr_background_handler_cache
# as a one-way communication between the core process and itself,
# and then handles asynchronous processes related to the stream threads.
__purr_background_handler() {
   __purr_start_streams

   while read line; do
      if [ $line = "stop" ]; then
        __purr_cleanup_streams
      elif [ $line = "start" ]; then
         __purr_start_streams
      elif [ $line = "cleanup" ]; then
         __purr_cleanup_streams
         exit 0
      fi
   done < <(/usr/bin/tail -f $purr_background_handler_cache 2> /dev/null)
}

# Spawns four threads that will simultaneously load the four streams from
# adb. These threads will stay alive until killed by the background handler.
__purr_start_streams() {
    __purr_stream_background_file $purr_error_input_cache "*:E" $purr_serial_cache &
    __purr_stream_background_file $purr_warning_input_cache "*:W" $purr_serial_cache &
    __purr_stream_background_file $purr_info_input_cache "*:I" $purr_serial_cache &
    __purr_stream_background_file $purr_verbose_input_cache "*:V" $purr_serial_cache &

    __purr_stream_unique_file $purr_error_input_cache $purr_error_input_cache_unique $purr_error_unique_checksum_cache &
    __purr_stream_unique_file $purr_warning_input_cache $purr_warning_input_cache_unique $purr_warning_unique_checksum_cache &
    __purr_stream_unique_file $purr_info_input_cache $purr_info_input_cache_unique $purr_info_unique_checksum_cache &
    __purr_stream_unique_file $purr_verbose_input_cache $purr_verbose_input_cache_unique $purr_verbose_unique_checksum_cache &
}

# We can just kill the stream threads; they only interact with
# the stream file, so we don't care about is happening when they die.
__purr_cleanup_streams() {
    kill ${${(v)jobstates##*:*:}%=*}
    for pid in ${${(v)jobstates##*:*:}%=*}; do
        wait $pid
    done

    rm $purr_error_input_cache &> /dev/null
    rm $purr_warning_input_cache &> /dev/null
    rm $purr_info_input_cache &> /dev/null
    rm $purr_verbose_input_cache &> /dev/null

    rm $purr_error_input_cache_unique &> /dev/null
    rm $purr_warning_input_cache_unique &> /dev/null
    rm $purr_info_input_cache_unique &> /dev/null
    rm $purr_verbose_input_cache_unique &> /dev/null
}

# The function that runs the stream threads. Each should run an
# adb process that feeds information into the given file. We also
# want to make sure that only one thread is handling shared logic,
# so the verbose thread is responsible for this, as it has the most
# context. Since these threads are the only ones who directly interact
# with adb logcat, they are also responsible for monitoring the connection
# state of the device and ensuring they can cleanly resume if we lose
# the device.
__purr_stream_background_file() {
    local stream_file=$1
    local stream_command=$2
    local purr_serial_cache=$3

    # We only want the verbose background stream to perform certain actions.
    if grep -q "verbose" <<< "$stream_file"; then
        local am_verbose="true"
    else
        local am_verbose="false"
    fi

    # If the directory doesn't exist anymore, it's likely that we have exited.
    touch $stream_file &> /dev/null
    if [ $? -ne 0 ]; then
        exit
    fi

    # We don't know anything about the connection yet, even
    # though we should be in a good state.
    conn_status="unknown"

    while true; do

        # Make sure we have the most up to date serial.
        serial=$(cat $purr_serial_cache 2> /dev/null)
        if [ -z $serial ]; then
            exit
        fi

        # If we disconnected, we want to make sure that the device is still offline.
        if [[ $conn_status = "potential" ]]; then
            timeout 2 "adb -s $serial wait-for-device" &> /dev/null

            # The device seems to have found itself, we can just reconnect.
            if [ $? -eq 0 ]; then
                echo "\x1b[1;36mPURR STATUS: Device Responding.\x1b[1;0m" >> $stream_file
                echo "\x1b[1;36mPURR STATUS: Restarting input from last seen timestamp.\x1b[1;0m" >> $stream_file
                conn_status="alive"
                if [ $am_verbose = "true" ]; then
                    echo "\x1b[1;32m  $serial => \x1b[1;0m" > $purr_connection_state_cache 
                fi
            else # Otherwise, we'll enter a dead state and start polling for the device.
                echo "\x1b[1;36mPURR STATUS: Device Not Responding.\x1b[1;0m" >> $stream_file
                echo "\x1b[1;36mPURR STATUS: Locking input streams until device found.\x1b[1;0m" >> $stream_file
                conn_status="dead"
                if [ $am_verbose = "true" ]; then
                    echo "\x1b[1;31m  $serial != \x1b[1;0m" > $purr_connection_state_cache
                fi
            fi
        else # If we aren't in potential mode, we poll for the device until we find it.
            adb -s $serial wait-for-device &> /dev/null
            if [ $? -eq 0 ]; then
                if [ $conn_status != "unknown" ]; then
                    echo "\x1b[1;36mPURR STATUS: Device Responding.\x1b[1;0m" >> $stream_file
                    echo "\x1b[1;36mPURR STATUS: Restarting input from last seen timestamp.\x1b[1;0m" >> $stream_file
                fi

                conn_status="alive"
                if [ $am_verbose = "true" ]; then
                    echo "\x1b[1;32m  $serial => \x1b[1;0m" > $purr_connection_state_cache
                fi
            fi
        fi
        
        # Once we've established a device connection, we'll start streaming from logcat.
        if [ $conn_status = "alive" ]; then

            # Handles trimming logcat input to a specific timestamp.
            trim_time=$(cat $purr_time_start_cache)
            if [ -z $trim_time ]; then
                eval "adb -s $serial logcat -v color $custom_adb_params '$stream_command' >> $stream_file"
            else
                
                # We don't want the trim time to survive a thread cleanup,
                # so once the verbose thread is sure all the other threads
                # have read it, we wipe the state cache.
                if [ $am_verbose = "true" ]; then
                    {
                        sleep 1.5
                        if [ -f $purr_time_start_cache ]; then
                            echo "" > $purr_time_start_cache &> /dev/null
                        fi
                    } &
                fi
                eval "adb -s $serial logcat -v color $custom_adb_params -T '$trim_time'  '$stream_command' >> $stream_file"
            fi

            # We've been disconnected, and we're not sure what the state is. We'll
            # grab the last message sent so we can restart at the same timestamp.
            if [ $am_verbose = "true" ]; then
                trimmed_time=$(echo $(tail -1 $stream_file) | cut -d' ' -f1-2 | sed -e 's/\x1b\[[0-9;]*m//g');
                echo $trimmed_time > $purr_time_start_cache;
            fi

            echo "\x1b[1;36mPURR STATUS: Potential Connection Lost.\x1b[1;0m" >> $stream_file
            conn_status="potential"
        fi

        sleep 0.5
    done
}

__purr_stream_unique_file() {
    local stream_input_file=$1
    local stream_output_file=$2
    local stream_checksum_file=$3

    # If the directory doesn't exist anymore, it's likely that we have exited.
    touch $stream_output_file &> /dev/null
    if [ $? -ne 0 ]; then
        exit
    fi

    # If the directory doesn't exist anymore, it's likely that we have exited.
    touch $stream_checksum_file &> /dev/null
    if [ $? -ne 0 ]; then
        exit
    fi

    tail -s 0.1 -F --lines=+0 -- $stream_input_file 2> /dev/null | while read -r line; do
        trimmed_line_cksum=$(echo $line | awk '{$1=$1};1' | cut -d' ' -f5- -- | cksum | cut -d' ' -f1)
        if command -v rg &>/dev/null; then
            if ! rg -q "$trimmed_line_cksum" $stream_checksum_file 2> /dev/null; then
                echo "$line" >> $stream_output_file
                echo "$trimmed_line_cksum" >> $stream_checksum_file
            else
                echo "Erasing duplicate line..." >> $stream_output_file
            fi
        else
            if ! /usr/bin/grep -q "$trimmed_line_cksum" $stream_checksum_file 2> /dev/null; then
                echo "$line" >> $stream_output_file
                echo "$trimmed_line_cksum" >> $stream_checksum_file
            else
                echo "Erasing duplicate line..." >> $stream_output_file
            fi
        fi
    done
}

# Usage command for help menu.
usage=("purr"
    "\n[-q: Sets the default query]"
    "\n[-i: Disables the instruction header]"
    "\n[-a: Set custom adb parameters as a string]"
    "\n[-f: Set custom fzf parameters as a string]"
    "\n[-v: Get version number]")

# Load the correct version of purr. We won't need this once fzf releases 0.40.0
# to the applicable places. For now, we sideload fzf. Otherwise, we load the 
# local fzf binary. Why these specific versions? Because this is an internal tool.
autoload is-at-least
if command -v fzf &> /dev/null && is-at-least "0.40.0" $(fzf --version | cut -d' ' -f1); then
    fzf_purr="fzf"
elif [ $(uname -s) = "Darwin" ]; then
    if [ $(arch) = "arm64" ]; then
        fzf_purr="purr_fzf_darwin_arm64"
    elif [ $(arch) = "i386" ]; then
        fzf_purr="purr_fzf_darwin_amd64"
    fi
elif [ $(uname -s) = "Linux" ]; then
    if [ $(uname -m) = "x86_64" ]; then
        fzf_purr="purr_fzf_linux_x86_64"
    fi
fi

if [ -z $fzf_purr ]; then
    echo "Could not identify valid fzf version."
    echo "purr requires fzf 0.40.0 or higher."
    exit 1
fi

# Depending on the situation we are in, we want a different version of pbcopy. 
# We'll always fall back to OSC-52 as last resort, but it's not optimal since
# we are sending TTY output, which makes fzf unhappy. 
if command -v pbcopy &> /dev/null && [ -z $SSH_TTY ]; then
    pbcopy_purr="$(which pbcopy)"
elif command -v wl-copy &> /dev/null && [ $XDG_SESSION_TYPE = "wayland" ]; then
    pbcopy_purr="wl-copy"
elif command -v xsel &> /dev/null && [ ! -z $DISPLAY ]; then
    pbcopy_purr="xsel --clipboard --input"
elif command -v purr_osc52_copy &> /dev/null; then
    pbcopy_purr="$(which purr_osc52_copy)"
fi

if [ -z $pbcopy_purr ]; then
    echo "Could not identify copy program."
    echo "purr will continue, but the Ctrl-Y hotkey will not work."
fi

VERSION="1.3.0"
COMPOSITE_VERSION="Purr: $VERSION, fzf: $($fzf_purr --version), zsh: $ZSH_VERSION"

# Parse argument flags.
instruction_flag=true
while getopts ':a:f:ivVq:' flags; do
    case $flags in
        q) query_string="--query=${OPTARG}" ;;
        a) custom_adb_params=${OPTARG} ;;
        f) custom_fzf_params=${OPTARG} ;;
        i) instruction_flag=false ;;
        v) echo $VERSION; exit 0 ;;
        V) echo $COMPOSITE_VERSION; exit 0 ;;
        *) echo $usage; exit 1 ;;
    esac
done

# Checks that we are in an environment that can run purr.
if ! __purr_check_env; then
    echo "Could not validate purr env. Exiting."
    exit 50
fi

# We need to use zsh for all commands within purr, including fzf commands. Since fzf
# grabs the SHELL from the environment variable, we need to make sure it's pointing to
# zsh for compatibility.
SHELL=$(which zsh)

# Create the directory our cache file will live.
rand_prefix=$(cat /dev/urandom | LC_ALL=C /usr/bin/tr -cd 'a-f0-9' | /usr/bin/head -c 8)
cur_time=$(($(date +%s) * 1000))
dir_name="/tmp/purr_${rand_prefix}_${cur_time}"
mkdir "$dir_name"

# Makes sure that we'll always run the cleanup if we exit
# abnormally, through ctrl-c for example.
trap "__purr_cleanup $dir_name" INT TERM

# Create the cache files we'll use to communicate with fzf.
__purr_create_files $dir_name

# Grabs a serial number from adb.
serial=$(pick_serial)
if [ $? -ne 0 ]; then
    echo $serial
    __purr_cleanup $dir_name
    exit 61
fi

# Load the serial number into the serial cache.    
echo $serial > $purr_serial_cache

# A secret tool which will help us later. We'll need this to make sure we're routing
# copy requests correctly through SSH and TMUX.
if [ -n "${TMUX-}" ]; then
    pane_active_tty=$(tmux list-panes -F "#{pane_active} #{pane_tty}" | awk '$1=="1" { print $2 }')
    if [ ! -z $SSH_TTY ]; then
        target_tty="${SSH_TTY:-$pane_active_tty}"
    else
        target_tty="${TTY:-$pane_active_tty}"
    fi
else
    target_tty="$TTY"
fi

# Prompt for each input stream.
stream_error_msg="\x1b[1;31mError\x1b[1;0m\t\t"
stream_warn_msg="\x1b[1;33mWarning\x1b[1;0m\t\t"
stream_info_msg="\x1b[1;32mInfo\x1b[1;0m\t\t"
stream_verbose_msg="\x1b[1;34mVerbose\x1b[1;0m\t\t"
stream_focus_msg="\x1b[1;35mFocus\x1b[1;0m\t\t"
stream_adb_msg="\x1b[1;35mADB\x1b[1;0m\t\t"

# Prompt for scroll lock on/off.
slock_on_msg="\x1b[1;31mOn   \x1b[1;0m"
slock_off_msg="\x1b[1;32mOff  \x1b[1;0m"

# Prompt for scroll lock on/off.
unique_on_msg="\x1b[1;31mOn   \x1b[1;0m"
unique_off_msg="\x1b[1;32mOff  \x1b[1;0m"

# Prompt for each sorting mode.
sorting_chronological="\x1b[1;35mChronological\x1b[1;0m\t"
sorting_relevance="\x1b[1;36mRelevance\x1b[1;0m\t\t"

# Some reasonable defaults for FZF.
fzf_params=('--exact' '--ansi' '--tac' '--no-sort' '--multi' $query_string)
fzf_pretty=('--info' 'inline' '--pointer' '>')
fzf_header=('--header-first')
label_header="     Date   $(date +"%Z %z")    PID   TID"
fzf_label=('--border-label' $label_header '--border-label-pos' '1:top')
fzf_gui=('--border' '--margin' '0.5%' '--padding' '0.5%' '--height' '100%')

fzfpnh=($fzf_params $fzf_pretty $fzf_gui $custom_fzf_params $fzf_label)
fzfp=($fzfpnh $fzf_header)

__purr_print_instructions $purr_instruction_cache

# Some reasonable defaults for adb logcat.
teecmd=("|" 'tee' $purr_input_cache)
check_adb_status=("|" 'grep' '-q' '-v' '"Lost connection to device."')

load_generic_header=(
    "echo -n \"Stream: \";"
    "cat $purr_stream_header_cache | tr -d \"\n\";"
    "echo -n \"Sort: \";"
    "cat $purr_sort_header_cache | tr -d \"\n\";"
    "echo -n \"Scroll Lock: \";"
    "cat $purr_slock_cache | tr -d \"\n\";"
    "echo -n \"Unique: \";"
    "cat $purr_unique_cache | tr -d \"\n\";"
    "echo \"\x1b[1;2;37mPurr: Happy Logcat\x1b[1;0m\";"
)

# Handles the UI logic of reloading the header.
load_input_stream=(
    "if /usr/bin/grep -q \"History\" $purr_stream_header_cache; then"
        "cat $purr_input_stream_cache | zsh;"
    "elif /usr/bin/grep -q \"Serial\" $purr_stream_header_cache; then"
        "cat $purr_input_stream_cache | zsh;"
    "elif /usr/bin/grep -q \"ADB\" $purr_stream_header_cache; then"
        # If the user runs a command, put the full command as the first line.
        "if /usr/bin/grep -q \"adb -s\" $purr_input_stream_cache; then"
            "echo \"Command: \$(cat $purr_input_stream_cache)\";"
        "fi;"
        "cat $purr_input_stream_cache | zsh |& tee;" # Prints all streams to stdout.
    'else;'
        "serial=\$(cat $purr_serial_cache);"
        'if adb devices | /usr/bin/grep $serial &> /dev/null; then'
            "echo \"\x1b[1;32m  \$serial => \x1b[1;0m\" >| $purr_connection_state_cache;"
        'else;'
            "echo \"\x1b[1;31m  \$serial != \x1b[1;0m\" >| $purr_connection_state_cache;"
        'fi;'

        "cat $purr_input_stream_cache | zsh;"
    "fi;"
)

# Handles the UI logic of scroll-locking the header.
lock_input_stream=(
    "cat $purr_input_cache;"
)

# Creates background workers to stream the logcat input streams for us.
( __purr_background_handler & )

set_stream_error="echo \"/usr/bin/tail -F -n 99999999 $purr_error_input_cache $teecmd\" >| $purr_input_stream_cache;"
set_stream_warning="echo \"/usr/bin/tail -F -n 99999999 $purr_warning_input_cache $teecmd\" >| $purr_input_stream_cache;"
set_stream_info="echo \"/usr/bin/tail -F -n 99999999 $purr_info_input_cache $teecmd\" >| $purr_input_stream_cache;"
set_stream_verbose="echo \"/usr/bin/tail -F -n 99999999 $purr_verbose_input_cache $teecmd\" >| $purr_input_stream_cache;"

set_stream_error_unique="echo \"/usr/bin/tail -F -n 99999999 $purr_error_input_cache_unique $teecmd\" >| $purr_input_stream_cache;"
set_stream_warning_unique="echo \"/usr/bin/tail -F -n 99999999 $purr_warning_input_cache_unique $teecmd\" >| $purr_input_stream_cache;"
set_stream_info_unique="echo \"/usr/bin/tail -F -n 99999999 $purr_info_input_cache_unique $teecmd\" >| $purr_input_stream_cache;"
set_stream_verbose_unique="echo \"/usr/bin/tail -F -n 99999999 $purr_verbose_input_cache_unique $teecmd\" >| $purr_input_stream_cache;"

set_stream_adb="echo \"/usr/bin/tail -F -n 99999999 $purr_adb_cache $teecmd\" >| $purr_input_stream_cache;"

stop_stream="echo \"stop\" >> $purr_background_handler_cache;"
start_stream="echo \"start\" >> $purr_background_handler_cache;"

# Sets the stream header to a given message.
set_header_error="echo \"$stream_error_msg\" >| $purr_stream_header_cache;"
set_header_warning="echo \"$stream_warn_msg\" >| $purr_stream_header_cache;"
set_header_info="echo \"$stream_info_msg\" >| $purr_stream_header_cache;"
set_header_verbose="echo \"$stream_verbose_msg\" >| $purr_stream_header_cache;"
set_header_focus="echo \"$stream_focus_msg\" >| $purr_stream_header_cache;"
set_header_adb="echo \"$stream_adb_msg\" >| $purr_stream_header_cache;"

# Sets the sort header to a given message.
set_sort_chrono="echo \"$sorting_chronological\" >| $purr_sort_header_cache;"
set_sort_relevance="echo \"$sorting_relevance\" >| $purr_sort_header_cache;"

# Saves the current query for an fzf reboot.
save_current_query="echo {q} > $purr_query_cache;"

# Sets the scroll lock header to a given state.
set_slock_on="echo \"$slock_on_msg\" >| $purr_slock_cache;"
set_slock_off="echo \"$slock_off_msg\" >| $purr_slock_cache;"

# Sets the scroll lock header to a given state.
set_unique_on="echo \"$unique_on_msg\" >| $purr_unique_cache;"
set_unique_off="echo \"$unique_off_msg\" >| $purr_unique_cache;"

# Boolean to determine state of scroll lock.
is_slock_on="/usr/bin/grep -q  \"On\" \"$purr_slock_cache\""

# Boolean to determine state of unique mode.
is_unique_on="/usr/bin/grep -q  \"On\" \"$purr_unique_cache\""

# Boolean to determine state of sort order.
is_sort_chrono="/usr/bin/grep -q  \"Chronological\" \"$purr_sort_header_cache\""

# Injects an empty line to force fzf to refresh the input stream.
inject_empty_line="echo \"\";"

bind_commands=()

# Bind: F7, set preview to the instruction menu..
instruction_preview_command="cat $purr_instruction_cache"
instruction_preview_window="right,50%,nohidden,nofollow,wrap,<55(up,50%,nohidden,nofollow,wrap)"
instruction_preview_window_hidden="right,50%,hidden,nofollow,wrap,<55(up,50%,hidden,nofollow,wrap)"
hint_preview=("change-preview($instruction_preview_command)+change-preview-window($instruction_preview_window)+change-preview-label()+refresh-preview")
bind_commands+=('--bind' "F7:$hint_preview\
+execute-silent(echo 'nohidden' >| $purr_preview_visible_cache; echo 'instruction' >| $purr_preview_command_cache)")

# Preview: Highlights selected line, and shows 200 lines of context around it.
# Bind: F9/10 for current/verbose stream, respectively.
current_hint_preview_command=$(cat <<-END
    # Grab the line number from the input cache. This may not be unique if multiple lines are exact matches.
    line_number="\$(/usr/bin/grep -F -n -- {} $purr_input_cache | cut -d':' -f1)";

    if [ -z "\$line_number" ]; then
        echo "Could not identify selected line in input buffer!";
        echo "This should never happen; please report me as a bug!";
    else;

        # Get only the first line to display.
        first_line_number="\$(/usr/bin/head -n 1 <<< "\$line_number")";

        # Get the number of lines in the input file for pointer math!
        lines_in_input_file="\$(/usr/bin/wc -l $purr_input_cache | xargs | cut -d' ' -f1)";

        # Get the lines we need to put into the preview file.
        line_number_min=\$((first_line_number-200));
        line_number_max=\$((first_line_number+200));

        # Try not to overflow from the input file.
        if [ \$line_number_max -ge \$lines_in_input_file ]; then
            line_number_max=\$lines_in_input_file;
        fi;

        # Try not to underflow from the input file.
        if [ \$line_number_min -le 0 ]; then
            pad_top_number=\$((200 - first_line_number))
            line_number_min=0;
        fi;

        # Get the number we need to tail for.
        tail_line_numbers=\$((\$line_number_max - \$line_number_min));

        # Get the lines that need to be printed from the input cache.
        full_lines=\$(/usr/bin/head -n \$line_number_max $purr_input_cache  | /usr/bin/tail -n \$tail_line_numbers -q;);

        # If we don't have enough lines on the top, we'll pad with new lines so that
        # fzf can still send us to above the correct line in the preview.
        if [ ! -z "\$pad_top_number" ]; then
            for i in {1..\$pad_top_number}; do
                padding_string="\$padding_string\n";
            done;
            full_lines="\$padding_string""\$full_lines";
        fi;

        # Start building the preview. We need to do this piecemeal to make sure we can 
        # highlight the relevant lines.
        preview_top=\$(echo \$full_lines | /usr/bin/head -n 199);

        # Since we aren't guarenteed that the selected line is unique, let's tell the user so 
        # they understand why the line might seem different.
        if [ "\$(/usr/bin/wc -l <<< "\$line_number")" -ne 1 ]; then
            info_panel="\\n----------------";
            info_panel+="\\nSeeing multiple exact matches; highlighting first instance."
            info_panel+="\\nFirst Instance on line \$first_line_number";
            info_panel+="\\nDuplicates on line(s) \$(echo \$line_number | /usr/bin/tail -n +2 | /usr/bin/tr '\n' ' ')";
            info_panel+="\\n----------------";
        fi;

        # Highlight the line the user selected.
        highlighted_line="\$(echo -- \$full_lines | /usr/bin/head -n 200 -- | /usr/bin/tail -n 1 -q -- | cat -v -- | /usr/bin/sed -e "s/\^\[\[[0-9;]*m/\x1b[1;36m/g")";

        # We might not have lines at the bottom to print, so we need to check
        # how big the padded buffer is.
        full_lines_size=\$(echo \$full_lines | /usr/bin/wc -l);
        bottom_line_numbers=\$((\$full_lines_size - 200));

        # Load in the bottom of the preview.
        preview_bottom=\$(echo \$full_lines | /usr/bin/tail -n \$bottom_line_numbers);

        # Construct and print the preview.
        constructed_preview="\$preview_top\$info_panel\\n\$highlighted_line\\n\$preview_bottom";
        echo "\$constructed_preview";
    fi;
END
)

verbose_hint_preview_command=$(cat <<-END
    # Grab the line number from the input cache. This may not be unique if multiple lines are exact matches.
    line_number="\$(/usr/bin/grep -F -n -- {} $purr_verbose_input_cache | cut -d':' -f1)";

    if [ -z "\$line_number" ]; then
        echo "Could not identify selected line in input buffer!";
        echo "This should never happen; please report me as a bug!";
    else;
        # Get only the first line to display.
        first_line_number="\$(/usr/bin/head -n 1 <<< "\$line_number")";

        # Get the number of lines in the input file for pointer math!
        lines_in_input_file="\$(/usr/bin/wc -l $purr_verbose_input_cache | xargs | cut -d' ' -f1)";

        # Get the lines we need to put into the preview file.
        line_number_min=\$((first_line_number-200));
        line_number_max=\$((first_line_number+200));

        # Try not to overflow from the input file.
        if [ \$line_number_max -ge \$lines_in_input_file ]; then
            line_number_max=\$lines_in_input_file;
        fi;

        # Try not to underflow from the input file.
        if [ \$line_number_min -le 0 ]; then
            pad_top_number=\$((200 - first_line_number))
            line_number_min=0;
        fi;

        # Get the number we need to tail for.
        tail_line_numbers=\$((\$line_number_max - \$line_number_min));

        # Get the lines that need to be printed from the input cache.
        full_lines=\$(/usr/bin/head -n \$line_number_max $purr_verbose_input_cache  | /usr/bin/tail -n \$tail_line_numbers -q;);

        # If we don't have enough lines on the top, we'll pad with new lines so that
        # fzf can still send us to above the correct line in the preview.
        if [ ! -z "\$pad_top_number" ]; then
            for i in {1..\$pad_top_number}; do
                padding_string="\$padding_string\n";
            done;
            full_lines="\$padding_string""\$full_lines";
        fi;

        # Start building the preview. We need to do this piecemeal to make sure we can 
        # highlight the relevant lines.
        preview_top=\$(echo \$full_lines | /usr/bin/head -n 199);

        # Since we aren't guarenteed that the selected line is unique, let's tell the user so 
        # they understand why the line might seem different.
        if [ "\$(/usr/bin/wc -l <<< "\$line_number")" -ne 1 ]; then
            info_panel="\\n----------------";
            info_panel+="\\nSeeing multiple exact matches; highlighting first instance."
            info_panel+="\\nFirst Instance on line \$first_line_number";
            info_panel+="\\nDuplicates on line(s) \$(echo \$line_number | /usr/bin/tail -n +2 | /usr/bin/tr '\n' ' ')";
            info_panel+="\\n----------------";
        fi;

        # Highlight the line the user selected.
        highlighted_line="\$(echo -- \$full_lines | /usr/bin/head -n 200 -- | /usr/bin/tail -n 1 -q -- | cat -v -- | /usr/bin/sed -e "s/\^\[\[[0-9;]*m/\x1b[1;36m/g")";

        # We might not have lines at the bottom to print, so we need to check
        # how big the padded buffer is.
        full_lines_size=\$(echo \$full_lines | /usr/bin/wc -l);
        bottom_line_numbers=\$((\$full_lines_size - 200));

        # Load in the bottom of the preview.
        preview_bottom=\$(echo \$full_lines | /usr/bin/tail -n \$bottom_line_numbers);

        # Construct and print the preview.
        constructed_preview="\$preview_top\$info_panel\\n\$highlighted_line\\n\$preview_bottom";
        echo "\$constructed_preview";
    fi;
END
)

hint_preview_window="top,70%,nohidden,wrap,+200/2"
hint_preview_window_hidden="top,70%,hidden,wrap,+200/2"

bind_commands+=('--bind' "F9:change-preview($current_hint_preview_command)+change-preview-label(Current Stream)\
+change-preview-window($hint_preview_window)\
+refresh-preview+execute-silent(echo 'nohidden' >| $purr_preview_visible_cache; echo 'current' >| $purr_preview_command_cache)")
bind_commands+=('--bind' "F10:change-preview($verbose_hint_preview_command)+change-preview-label(Verbose Stream)\
+change-preview-window($hint_preview_window)\
+refresh-preview+execute-silent(echo 'nohidden' >| $purr_preview_visible_cache; echo 'verbose' >| $purr_preview_command_cache)")

# Preview: Highlights selected line, and shows 200 lines of context around it in the selected input stream.
# Bind: Ctrl-P, toggle preview on/off.
bind_commands+=('--bind' "ctrl-p:toggle-preview+execute-silent(\
if [ \$(cat $purr_preview_visible_cache) = 'nohidden' ]; then;\
    echo 'hidden' >| $purr_preview_visible_cache;\
else;\
    echo 'nohidden' >| $purr_preview_visible_cache;\
fi\
)")

# List of keys to bind when we load an input stream. We want to unbind these keys when we go to a non-input stream,
# like history. Otherwise, we start getting undefined behaviors.
default_command_suite="rebind(f1)\
+rebind(f2)\
+rebind(f3)\
+rebind(f4)\
+rebind(f5)\
+rebind(f6)\
+rebind(f7)\
+rebind(f9)\
+rebind(f10)\
+rebind(ctrl-p)\
+rebind(ctrl-r)\
+rebind(ctrl-s)\
+rebind(ctrl-u)\
+rebind(ctrl-j)\
+rebind(ctrl-f)\
+rebind(ctrl-w)\
+rebind(ctrl-t)\
+rebind(ctrl-alt-t)\
+rebind(tab)\
+rebind(ctrl-v)\
+rebind(ctrl-y)\
+rebind(ctrl-alt-s)\
+rebind(ctrl-alt-d)\
+unbind(enter)\
+unbind(ctrl-h)\
+unbind(double-click)"

# Bind: F1, show logcat error stream.
error_cmd=(
    'execute-silent('
        '{'
            "if $is_unique_on; then"
                $set_stream_error_unique
            "else;"
                $set_stream_error
            "fi;"
            $set_header_error
            $set_slock_off
        '} &'
    ')+reload('
        $inject_empty_line
        $load_input_stream
    ")+transform-header("
        $load_generic_header
    ")+first+enable-search+$default_command_suite"
)
bind_commands+=('--bind' "f1:$error_cmd")

# Bind: F2, show logcat warning stream.
warn_cmd=(
    'execute-silent('
        '{'
            "if $is_unique_on; then"
                $set_stream_warning_unique
            "else;"
                $set_stream_warning
            "fi;"
            $set_header_warning
            $set_slock_off
        '} &'
    ')+reload('
        $inject_empty_line
        $load_input_stream
    ")+transform-header("
        $load_generic_header
    ")+first+enable-search+$default_command_suite"
)
bind_commands+=('--bind' "f2:$warn_cmd")

# Bind: F3, show logcat info stream.
info_cmd=(
    'execute-silent('
        '{'
            "if $is_unique_on; then"
                $set_stream_info_unique
            "else;"
                $set_stream_info
            "fi;"
            $set_header_info
            $set_slock_off
        '} &'
    ')+reload('
        $inject_empty_line
        $load_input_stream
    ")+transform-header("
        $load_generic_header
    ")+first+enable-search+$default_command_suite"
)
bind_commands+=('--bind' "f3:$info_cmd")

# Bind: F4, show logcat verbose stream.
verb_cmd=(
    'execute-silent('
        '{'
            "if $is_unique_on; then"
                $set_stream_verbose_unique
            "else;"
                $set_stream_verbose
            "fi;"
            $set_header_verbose
            $set_slock_off
        '} &'
    ')+reload('
        $inject_emppty_line
        $load_input_stream
    ")+transform-header("
        $load_generic_header
    ")+first+enable-search+$default_command_suite"
)
bind_commands+=('--bind' "f4:$verb_cmd")

# Bind: ctrl-u, set unique mode on.
unique_cmd=(
    'execute-silent('
        "if $is_unique_on; then"
            $set_unique_off
            "sed -i 's/verbose-unique/verbose/g' $purr_input_stream_cache;"
            "sed -i 's/info-unique/info/g' $purr_input_stream_cache;"
            "sed -i 's/warning-unique/warning/g' $purr_input_stream_cache;"
            "sed -i 's/error-unique/error/g' $purr_input_stream_cache;"
        "else;"
            $set_unique_on
            "sed -i 's/verbose/verbose-unique/g' $purr_input_stream_cache;"
            "sed -i 's/info/info-unique/g' $purr_input_stream_cache;"
            "sed -i 's/warning/warning-unique/g' $purr_input_stream_cache;"
            "sed -i 's/error/error-unique/g' $purr_input_stream_cache;"
        "fi;"
    ')+reload('
        $inject_emppty_line
        $load_input_stream
    ")+transform-header("
        $load_generic_header
    ")+first+enable-search+$default_command_suite"
)
bind_commands+=('--bind' "ctrl-u:$unique_cmd")

adb_command_suite="rebind(f1)\
+rebind(f2)\
+rebind(f3)\
+rebind(f4)\
+rebind(f5)\
+rebind(f6)\
+unbind(f7)\
+unbind(f9)\
+unbind(f10)\
+unbind(ctrl-p)\
+unbind(ctrl-r)\
+rebind(ctrl-s)\
+unbind(ctrl-u)\
+rebind(ctrl-j)\
+rebind(ctrl-f)\
+unbind(ctrl-w)\
+unbind(ctrl-t)\
+unbind(ctrl-alt-t)\
+rebind(tab)\
+rebind(ctrl-v)\
+rebind(ctrl-y)\
+rebind(enter)\
+rebind(ctrl-h)\
+unbind(ctrl-alt-s)\
+unbind(ctrl-alt-d)\
+unbind(double-click)"

# Bind: F6, open adb command mode.
adb_stream_cmd=(
    'execute-silent('
        '{'
            $set_stream_adb
            $set_header_adb
            $set_slock_off
        '} &'
    ')+reload('
        $inject_empty_line
        $load_input_stream
    ")+transform-header("
        $load_generic_header
    ")+first+disable-search+hide-preview+$adb_command_suite+execute-silent(echo 'hidden' >| $purr_preview_visible_cache;)"
)
bind_commands+=('--bind' "f6:$adb_stream_cmd")

# Bind: Ctrl-h, ask for help in ADB command mode.
adb_help_cmd=(
    'execute-silent('
        '{'
            $set_stream_adb
            $set_header_adb
            $set_slock_off
        '} &'
        "serial=\$(cat $purr_serial_cache);"
        'query={q};'
        'for string in "--help" "-h" "help"; do'
            'adb_help=$( { eval "adb -s $serial shell $query $string" } 2>&1 );'
            'ret=$?;'
            # We are trying best-guesses on what a help prompt might look like here. There isn't
            # a standard for shell commands, so we're going to try the most common ones, and we 
            # assume that if a request returns a bunch of lines, maybe it's just dumping help.
            'if { [ $ret -eq 0 ] && [ ! -s $adb_help ] } || [ $(wc -l <<< $adb_help) -ge 15 ]; then'
                "echo \"Ran \\\"adb -s \$serial shell \$query \$string\\\"\"  > $purr_adb_cache;"
                "echo \$adb_help >> $purr_adb_cache;"
                "exit;"
            'fi;'
        'done;'
        "echo \"Could not find help for \\\"\$query\\\"\" >> $purr_adb_cache;"
    ')+reload('
        $load_input_stream
    ')+disable-search'
)
bind_commands+=('--bind' "ctrl-h:$adb_help_cmd")

# Bind: ctrl-alt-s, get tag from line and add it to query.
get_tag_cmd=(
    'execute-silent('
        'tag=$(echo "{}" | xargs | xargs | cut -d" " -f6);'
        'cur_query=$(echo "{q}" | xargs | xargs);'
        'if echo $cur_query | /usr/bin/grep -w -q -- "$tag"; then'
            "echo \"\$cur_query\" > $purr_query_cache;"
        'elif [ -z $cur_query ]; then'
            "echo \"\$tag\" > $purr_query_cache;"
        'else;'
            "echo \"\$cur_query \$tag\" > $purr_query_cache;"
        'fi;'
    ')+transform-query('
        "cat $purr_query_cache;"
        "echo "" > $purr_query_cache;"
    ')'
)
bind_commands+=('--bind' "ctrl-alt-s:$get_tag_cmd")

# Bind: ctrl-alt-d, get tag from line and add it as negative query.
remove_tag_cmd=(
    'execute-silent('
        'tag=$(echo "{}" | xargs | xargs | cut -d" " -f6);'
        'negative_tag="!$tag";'
        'cur_query=$(echo "{q}" | xargs | xargs);'
        'if echo $cur_query | /usr/bin/grep -w -q -- "$tag"; then'
            'untagged_query=$(echo "$cur_query" | /usr/bin/sed "s/\b$tag\b//g" | /usr/bin/sed "s/\b$tag//g" | xargs);'
            "echo \"\$untagged_query\" > $purr_query_cache;"
        'elif [ -z $cur_query ]; then'
            "echo \"\$negative_tag\" > $purr_query_cache;"
        'else;'
            "echo \"\$cur_query \$negative_tag\" > $purr_query_cache;"
        'fi;'
    ')+transform-query('
        "cat $purr_query_cache;"
        "echo "" > $purr_query_cache;"
    ')'
)
bind_commands+=('--bind' "ctrl-alt-d:$remove_tag_cmd")

# Bind: ctrl-s, stop stream and show input cache.
stop_cmd=(
    'execute-silent('
         '{'
            "if $is_slock_on; then"
                $set_slock_off
            "else"
                $set_slock_on
            "fi"
        '} &'
    ')+toggle-track+transform-header('
        $load_generic_header
    ")+$default_command_suite"
)
bind_commands+=('--bind' "ctrl-s:$stop_cmd")

# Bind: ctrl-w, send a cache wipe request to logcat.
wipe_cmd=(
    'execute-silent('
        $stop_stream
        "serial=\$(cat $purr_serial_cache);"
        'adb -s $serial logcat -c;'
        $set_slock_off
        "echo 'wipe' > $purr_accept_command_cache;"
        $save_current_query
        $start_stream
    ')+accept'
)
bind_commands+=('--bind' "ctrl-w:$wipe_cmd")

# Bind: ctrl-t, trim input to the end of the file.
trim_cmd=(
    'execute-silent('
        "trimmed_time=\$(echo {} | cut -d' ' -f1-2);"
        'if [ ! -z $trimmed_time ]; then'
            $stop_stream
            "serial=\$(cat $purr_serial_cache);"
            $set_slock_off
            "echo 'trim' > $purr_accept_command_cache;"
            # Grab the timestamp from the selected message.
            "echo \$trimmed_time > $purr_time_start_cache;"
            $save_current_query
            $start_stream
        'fi;'
    ')+accept-non-empty'
)
bind_commands+=('--bind' "ctrl-t:$trim_cmd")

# Bind: ctrl-alt-t, de-trim input.
untrim_cmd=(
    'execute-silent('
        $stop_stream
        "serial=\$(cat $purr_serial_cache);"
        $set_slock_off
        "echo 'trim' > $purr_accept_command_cache;"
        "echo '' > $purr_time_start_cache;"
        $save_current_query
        $start_stream
    ')+accept'
)
bind_commands+=('--bind' "ctrl-alt-t:$untrim_cmd")

# Bind: ctrl-f, brings the user to the currently selected entry.
bind_commands+=('--bind' "ctrl-f:track+clear-query+hide-preview+execute-silent(echo 'hidden' >| $purr_preview_visible_cache;)")

# Bind: ctrl-j, toggle chronological/relevance sort.
cmd_sort=(
    "toggle-sort+execute-silent("
        '{'
            "if $is_sort_chrono; then"
                $set_sort_relevance
            "else"
                $set_sort_chrono
            "fi"
        '} &'
    ")+transform-header("
        $load_generic_header
    ")+$default_command_suite"
)
bind_commands+=('--bind' "ctrl-j:$cmd_sort")

# Bind: ctrl-y, print to clipboard.
cmd_clipboard=(
    "execute-silent("
        "lines=\"{+}\";"
        'eval "line_array=($lines)";'
        'new_line_array=$(printf "%s\n" "${line_array[@]}");'
        "echo \"\$new_line_array[@]\" | $pbcopy_purr > $target_tty;"
    ')+clear-selection'
)
bind_commands+=('--bind' "ctrl-y:$cmd_clipboard")

# Bind: ctrl-\, prints device information to the clipboard.
cmd_clipboard=(
    'execute-silent('
        "serial=\$(cat $purr_serial_cache);"
        'info_array=("\`\`\`");'
        'info_array+=("\nFingerprint:" $(adb -s $serial shell getprop | grep "ro.build.fingerprint"));'
        'info_array+=("\nSDK Version:" $(adb -s $serial shell getprop | grep "ro.build.version.sdk"));'
        'info_array+=("\nGMS Version:" $(adb -s $serial shell dumpsys package com.google.android.gms | grep "versionName" | /usr/bin/head -n 1));'
        'info_array+=("\n\`\`\`");'
        "echo \"\$info_array\" | $pbcopy_purr > $target_tty;"
        '{'
            'bug_report_name="/tmp/bugreport-$(adb -s $serial shell getprop ro.product.vendor.name)-$(adb -s $serial shell getprop ro.product.vendor.device)-$(adb -s $serial shell getprop ro.vendor.build.version.sdk)-$(date +"%d-%m-%Y::%H:%M:%S")";'
            'bug_report_error=$(adb -s $serial bugreport $bug_report_name);'
            'if [ ! -f "${bug_report_name}.zip" ]; then '
                'echo $bug_report_error > "${bug_report_name}_err";'
            'fi;'
        '} &'
    ')+clear-selection'
)
bind_commands+=('--bind' "ctrl-\:$cmd_clipboard")

# Bind: home/end, similar to page-up/page-down for preview.
bind_commands+=('--bind' "home:preview-page-up")
bind_commands+=('--bind' "end:preview-page-down")

# Bind: ctrl-v, for going to the text editor.
cmd_editor=(
    "execute-silent("
        "accepted=\$(echo {});"
        'if [ ! -z $accepted ]; then'
            "echo 'editor' > $purr_accept_command_cache;"
            $save_current_query
        'fi;'
    ')+accept-non-empty'
)
bind_commands+=('--bind' "ctrl-v:$cmd_editor")

# Adds logic for handling history and serial selection.
stream_history_msg="\x1b[1;36mHistory\x1b[1;0m\t\t"
stream_serial_msg="\x1b[1;36mSerial\x1b[1;0m\t\t"

set_stream_history="echo \"cat $purr_history_cache\" >| $purr_input_stream_cache;"
set_header_history="echo \"$stream_history_msg\" >| $purr_stream_header_cache;"

set_stream_serial="echo \"adb devices | /usr/bin/tail -n +2 |/usr/bin/sed '/^\s*$/d' | /usr/bin/sort | awk '{print \$ 1}'\" >| $purr_input_stream_cache;"
set_header_serial="echo \"$stream_serial_msg\" >| $purr_stream_header_cache;"

# List of keys to bind when we load the history stream.
history_command_suite="rebind(f1)\
+rebind(f2)\
+rebind(f3)\
+rebind(f4)\
+rebind(f5)\
+rebind(f6)\
+unbind(f7)\
+unbind(f9)\
+unbind(f10)\
+unbind(ctrl-p)\
+unbind(ctrl-r)\
+unbind(ctrl-s)\
+unbind(ctrl-u)\
+rebind(ctrl-j)\
+unbind(ctrl-f)\
+unbind(ctrl-w)\
+unbind(ctrl-t)\
+unbind(ctrl-alt-t)\
+unbind(tab)\
+unbind(ctrl-v)\
+unbind(ctrl-y)\
+rebind(enter)\
+unbind(ctrl-h)\
+unbind(ctrl-alt-s)\
+unbind(ctrl-alt-d)\
+unbind(double-click)"
serial_command_suite="$history_command_suite"

# Bind: F5, show serial stream.
serial_cmd=(
    'execute-silent('
        '{'
            $set_stream_serial
            $set_header_serial
            $set_slock_off
        '} &'
    ')+reload('
        $load_input_stream
    ")+transform-header("
        $load_generic_header
    ")+first+enable-search+hide-preview+$serial_command_suite+execute-silent(echo 'hidden' >| $purr_preview_visible_cache;)"
)
bind_commands+=('--bind' "f5:$serial_cmd")

echo 0 >| $purr_history_counter_cache

# This code is a bit arcane, but here's basically what it's doing.
# When the query changes, we write an integer and start a timer.
# Once the timer ends, we check the integer; if it's not the same,
# we don't write to history. If it is, we check if we can find the
# query in the history file. We'll then either write it or move it
# to the top. This holistically allows us to write to history even 
# though queries are never "submitted".
history_input=(
    'execute-silent('
        '{'
            "seen_counter=\$(cat $purr_history_counter_cache);"
            '$(( seen_counter += 1 ));'
            "echo \$seen_counter >| $purr_history_counter_cache;"
            'sleep 3.5;'
            "cur_counter=\$(cat $purr_history_counter_cache);"
            'if [ $seen_counter -eq $cur_counter ]; then'
                'query={q};'
                "query=\$(echo \"\$query\" | xargs | tr -s ' ');"
                'if [ -z "$query" ]; then'
                    ':;'
                "elif /usr/bin/grep -cim1 -x \" *\$query *\" $purr_history_cache; then"
                    "line=\$(/usr/bin/grep -n -x \" *\$query *\" $purr_history_cache | cut -d : -f 1);"
                    "/usr/bin/sed -i \"\${line}d\" $purr_history_cache;"
                    "echo \$query >> $purr_history_cache;"  
                    "echo 0 >| $purr_history_pointer_cache;"
                'else;'
                    "echo \$query >> $purr_history_cache;"
                    "echo 0 >| $purr_history_pointer_cache;"
                'fi;'
            'fi;'
        '} &'
    ')'
)

bind_commands+=('--bind' "change:$history_input")

# This just allows the user to use alt-shift-up/down to traverse
# history. We just keep track in the file of where they are. We
# wipe this pointer wheneever we add a new history entry.
echo -1 >| $purr_history_pointer_cache
history_up=(
    'transform-query('
        "line_count=\$(/usr/bin/wc -l < $purr_history_cache);"
        "cur_pointer=\$(cat $purr_history_pointer_cache);"
        '$(( cur_pointer += 1 ));'
        'if [ $cur_pointer -lt $line_count ]; then'
            "echo \$cur_pointer >| $purr_history_pointer_cache;"
        'else;'
            '$(( cur_pointer -= 1));'
        'fi;'
        'line_to_get="$((line_count - cur_pointer))";'
        "/usr/bin/sed -n -e \${line_to_get}p $purr_history_cache;"
    ')'
)

# See above.
history_down=(
    'transform-query('
        "line_count=\$(/usr/bin/wc -l < $purr_history_cache);"
        "cur_pointer=\$(cat $purr_history_pointer_cache);"
        '$(( cur_pointer -= 1 ));'
        'if [ $cur_pointer -ge -1 ]; then'
            "echo \$cur_pointer >| $purr_history_pointer_cache;"
        'else;'
            '$(( cur_pointer += 1));'
        'fi;'
        'line_to_get="$((line_count - cur_pointer))";'
        "/usr/bin/sed -n -e \${line_to_get}p $purr_history_cache;"
    ')'
)

bind_commands+=('--bind' "alt-shift-up:$history_up")
bind_commands+=('--bind' "alt-shift-down:$history_down")

# Bind: ctrl-r, show history file.
history_cmd=(
    'execute-silent('
        '{'
            $set_stream_history
            $set_header_history
            $set_slock_off
        '} &'
    ')+reload('
        $load_input_stream
    ")+transform-header("
        $load_generic_header
    ")+clear-query+first+hide-preview+enable-search+$history_command_suite+execute-silent(echo 'hidden' >| $purr_preview_visible_cache;)"
)
bind_commands+=('--bind' "ctrl-r:$history_cmd")

# We overload the hell of this command...
# Bind: enter, select history command or serial selection.
enter_cmd=( 
    'transform-query('
        "if /usr/bin/grep -q \"History\" $purr_stream_header_cache; then"
            'echo {};'
        'else;'
            'echo {q};'
        'fi;'
    ')+execute-silent('
        "if /usr/bin/grep -q \"History\" $purr_stream_header_cache; then"
            "echo 'history' > $purr_accept_command_cache;"
            $set_stream_verbose
            $set_header_verbose
            $set_slock_off
            $save_current_query
        "elif /usr/bin/grep -q \"Serial\" $purr_stream_header_cache; then"
            $stop_stream
            "accepted=\$(echo {});"
            'if [ ! -z $accepted ]; then'
                "echo {} > $purr_serial_cache;"
            'fi;'
            "echo 'serial' > $purr_accept_command_cache;"
            $set_stream_verbose
            $set_header_verbose
            $set_slock_off
            $save_current_query
            $start_stream
        "elif /usr/bin/grep -q \"ADB\" $purr_stream_header_cache; then"
            $set_slock_off
            "echo 'adb_cmd' > $purr_accept_command_cache;"
            $save_current_query
        "fi;"
    ')+accept'
)
bind_commands+=('--bind' "enter:$enter_cmd")

# Adds logic to handle the prompt change to track serial numbers.
focus_cmd=(
    'transform-prompt('
        " connection_state=\$(cat $purr_connection_state_cache);"
        'echo $connection_state;'
    ')'
)
bind_commands+=('--bind' "focus:$focus_cmd")

# Command to exit purr.
esc_cmd=(
    'execute-silent('
        "echo 'escape' > $purr_accept_command_cache;"
    ')+accept'
)
bind_commands+=('--bind' "esc:$esc_cmd")


# Set the default program state.
echo "\x1b[1;32m  $serial => \x1b[1;0m" > $purr_connection_state_cache
echo $stream_verbose_msg >| $purr_stream_header_cache
echo $slock_off_msg >| $purr_slock_cache
echo $unique_off_msg >| $purr_unique_cache
echo $sorting_chronological >| $purr_sort_header_cache
echo "/usr/bin/tail -F -n 99999999 $purr_verbose_input_cache $teecmd" >| $purr_input_stream_cache

local instruction_preview_starter=("--preview"
    "$instruction_preview_command"
    "--preview-window"
    "$instruction_preview_window")

local current_hint_preview_starter=("--preview"
    "$current_hint_preview_command"
    "--preview-window"
    "$hint_preview_window"
    "--preview-label"
    "Current Stream")

local verbose_hint_preview_starter=("--preview"
    "$verbose_hint_preview_command"
    "--preview-window"
    "$hint_preview_window"
    "--preview-label"
    "Verbose Stream")

local instruction_preview_starter_hidden=("--preview"
    "$instruction_preview_command"
    "--preview-window"
    "$instruction_preview_window_hidden")

local current_hint_preview_starter_hidden=("--preview"
    "$current_hint_preview_command"
    "--preview-window"
    "$hint_preview_window_hidden"
    "--preview-label"
    "Current Stream")

local verbose_hint_preview_starter_hidden=("--preview"
    "$verbose_hint_preview_command"
    "--preview-window"
    "$hint_preview_window_hidden"
    "--preview-label"
    "Verbose Stream")

initial_pos_argument=""

# Keep looping fzf until the user escapes, to support opening in text editors.
while true; do
    defcmd=(
        $load_input_stream
    )

    # If we have a cahced query, either from history or another
    # fzf-ending command, retrieve it.
    cached_query="$(cat $purr_query_cache)"
    "" > $purr_query_cache &> /dev/null

    # Make sure our serial is up to date.
    serial=$(cat $purr_serial_cache)
    fzf_prompt=('--prompt' "  $serial -> ")

    if /usr/bin/grep -q "History" $purr_stream_header_cache; then
        start_command=('--bind' "start:hide-preview+transform-header($load_generic_header)+$history_command_suite")
    elif /usr/bin/grep -q "ADB" $purr_stream_header_cache; then
        start_command=('--bind' "start:hide-preview+transform-header($load_generic_header)+$adb_command_suite")
        if [ "$cached_query" = "Give me cat facts!" ]; then
            cat << "EOF" > $purr_spc_purpose_cache
                             _                    )
                            ( \_                  |
                      _,-'/'_ , ;-.               \
.                  ,-'  O  ( ` .<= `.              \
 `.              ,'o O o 0     o , ,'-.           ,-'
`. `.          ,'o O 0/ 0 )___,.--','"""`--._,,--'
__>. \       ,: ' o O/. o/  __,`--'-.                _,-'
-._   `-``._/o 0 0(),| o/-''         `-.__      __,-'|
   )_.   ` / ~':o ,-.\o \                 `----'     |
      `-.-| 0 o.`.\ /o|`.|                           |
          /o . ;.'`o|'|o \                           /
          |`,,'  `._/0|\',\                         /
          |`.|`._/ \o'||o |                         |
         /,`/       )./|.'|                         /
---------|.|--------\,\`--'-------------------------\
         |O|         \``.                           |
         |o|          `._)                          \
         |(|                                         \
         |O|                                          |
  hh     |)|                                          |
         /(|                                          |
        (o/                                           |
         \)                                           /
Cats who can purr can't roar, and vice-versa. 
Cheetahs can't roar, but they can meow and purr. 
This is because cheetahs are the cutest kittens at heart.
This has been Cat Facts with Alfred.
EOF
            adb_query_cmd="cat $purr_spc_purpose_cache"
        else
            adb_query_cmd="adb -s $serial shell $cached_query"
        fi

        cached_query=""
        echo $adb_query_cmd > $purr_input_stream_cache
    else
        start_command=('--bind' "start:transform-header($load_generic_header)+$default_command_suite")
    fi

    prev_preview=$(cat $purr_preview_command_cache)
    prev_preview_vis=$(cat $purr_preview_visible_cache)

    if [ "$prev_preview" = "instruction" ]; then
        if [ "$prev_preview_vis" = "hidden" ]; then
            local starter_preview_command=($instruction_preview_starter_hidden)
        elif [ "$prev_preview_vis" = "nohidden" ]; then
            local starter_preview_command=($instruction_preview_starter)
        fi
    elif [ "$prev_preview" = "verbose" ]; then
        if [ "$prev_preview_vis" = "hidden" ]; then
            local starter_preview_command=($verbose_hint_preview_starter_hidden)
        elif [ "$prev_preview_vis" = "nohidden" ]; then
            local starter_preview_command=($verbose_hint_preview_starter)
        fi
    elif [ "$prev_preview" = "current" ]; then
        if [ "$prev_preview_vis" = "hidden" ]; then
            local starter_preview_command=($current_hint_preview_starter_hidden)
        elif [ "$prev_preview_vis" = "nohidden" ]; then
            local starter_preview_command=($current_hint_preview_starter)
        fi
    elif [ $instruction_flag = "true" ]; then
        local starter_preview_command=($instruction_preview_starter)
        echo "instruction" > $purr_preview_command_cache
        echo "nohidden" > $purr_preview_visible_cache
    else
        local starter_preview_command=($verbose_hint_preview_starter_hidden)
        echo "verbose" > $purr_preview_command_cache
        echo "hidden" > $purr_preview_visible_cache
    fi

    # Starts and runs the actual fzf process.
    if [ ! -z $cached_query ]; then
        accepted=$(FZF_DEFAULT_COMMAND="$defcmd" $fzf_purr $starter_preview_command $fzfp $fzf_prompt $bind_commands $start_command --query=$cached_query)
        ret=$?
    else
        accepted=$(FZF_DEFAULT_COMMAND="$defcmd" $fzf_purr $starter_preview_command $fzfp $fzf_prompt $bind_commands $start_command)
        ret=$?
    fi

    cached_query=""
    accept_cmd=""

    # 0 is normal exit, 1 is exit with no accepted. We don't
    # want any exit codes here.
    if [ $ret -ne 0 ] && [ $ret -ne 1 ]; then
        break
    fi
    
    # The async processes might take a bit of time to
    # get the accept command in.
    timeout 1 "wait_for_file $purr_accept_command_cache"
    
    # We'll use this to figure out the user input before fzf stopped.
    accept_cmd=$(cat $purr_accept_command_cache)
    "" > $purr_accept_command_cache &> /dev/null

    # Abort from the loop if the user has sent an escape command.
    if [ -z $accept_cmd ] || [ $accept_cmd = "escape" ]; then
        break
    fi

    if [ $accept_cmd = "wipe" ]; then
        wait_for_input_streams
        continue
    elif [ $accept_cmd = "adb_cmd" ]; then
        continue
    elif [ $accept_cmd = "serial" ]; then
        wait_for_input_streams
        continue
    elif [ $accept_cmd = "history" ]; then
        continue
    elif [ $accept_cmd = "trim" ]; then
        wait_for_input_streams
        continue
    elif [ $accept_cmd = "editor" ]; then

        if [ -z $accepted ]; then
            continue
        fi 

        # Grab the context around the accepted line.
        if [ $(echo $accepted | wc -l) -eq 1 ]; then
            if command -v rg &> /dev/null; then
                rg --color=always -F "$accepted" $purr_input_cache -C 500 > $purr_editor_input_cache
            else 
                /usr/bin/grep --color=always -F "$accepted" $purr_input_cache -C 500 > $purr_editor_input_cache
            fi
        else
            echo $accepted > $purr_editor_input_cache
        fi

        # Preferentially grab the editor from $EDITOR_PURR, then $EDITOR, then just use vim.
        if [ $EDITOR_PURR ]; then
            eval "$EDITOR_PURR $purr_editor_input_cache"
        elif [ $EDITOR ]; then
            eval "$EDITOR $purr_editor_input_cache"
        else
            echo "No editor detected. Overriding to vim."
            echo "Purr will read from \$EDITOR_PURR, then \$EDITOR, then default to vim."
            vim +501 $purr_editor_input_cache
        fi
    else
        break
    fi
done

__purr_cleanup $dir_name
